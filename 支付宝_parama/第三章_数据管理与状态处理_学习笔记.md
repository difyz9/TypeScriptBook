# 第三章：数据管理与状态处理 - 学习笔记

## 3.1 数据绑定和渲染

### 数据绑定语法

#### 1. 基础数据绑定
```xml
<!-- 文本内容绑定 -->
<text>{{message}}</text>

<!-- 属性绑定 -->
<image src="{{imageSrc}}" />

<!-- 样式绑定 -->
<view style="color: {{textColor}}; font-size: {{fontSize}}rpx;">动态样式</view>

<!-- 类名绑定 -->
<view class="container {{isActive ? 'active' : 'inactive'}}">条件类名</view>
```

#### 2. 表达式支持
```xml
<!-- 运算表达式 -->
<text>{{price * quantity}}</text>
<text>{{firstName + ' ' + lastName}}</text>
<text>{{age >= 18 ? '成年人' : '未成年人'}}</text>

<!-- 逻辑表达式 -->
<view a:if="{{score > 90 && passed}}">优秀</view>
<text>{{list.length > 0 ? '有数据' : '暂无数据'}}</text>

<!-- 对象属性访问 -->
<text>{{user.profile.name}}</text>
<text>{{user['email']}}</text>

<!-- 数组索引访问 -->
<text>{{colors[0]}}</text>
<text>{{matrix[0][1]}}</text>
```

#### 3. 模板字符串
```xml
<!-- 字符串拼接 -->
<text>{{`Hello, ${username}!`}}</text>
<image src="{{`https://api.example.com/avatar/${userId}.jpg`}}" />

<!-- 复杂模板 -->
<text>{{`订单金额: ¥${(price * quantity).toFixed(2)}`}}</text>
```

### 列表渲染（a:for）

#### 1. 基础列表渲染
```xml
<!-- 简单数组渲染 -->
<view a:for="{{items}}" a:key="index">
  <text>{{index}}: {{item}}</text>
</view>

<!-- 对象数组渲染 -->
<view a:for="{{userList}}" a:key="id">
  <text>{{item.name}} - {{item.email}}</text>
</view>
```

#### 2. 自定义变量名
```xml
<!-- 自定义循环变量名 -->
<view a:for="{{products}}" a:for-item="product" a:for-index="idx" a:key="id">
  <text>第{{idx + 1}}个商品: {{product.name}}</text>
  <text>价格: ¥{{product.price}}</text>
</view>
```

#### 3. 嵌套循环
```xml
<!-- 二维数组渲染 -->
<view a:for="{{categories}}" a:for-item="category" a:key="categoryId">
  <text class="category-title">{{category.name}}</text>
  <view a:for="{{category.items}}" a:for-item="product" a:key="productId">
    <text class="product-item">{{product.name}}</text>
  </view>
</view>
```

#### 4. 复杂列表示例
```xml
<!-- 商品列表 -->
<view class="product-list">
  <view class="product-item" 
        a:for="{{productList}}" 
        a:key="id"
        onTap="onProductTap"
        data-product-id="{{item.id}}">
    
    <image class="product-image" src="{{item.image}}" />
    
    <view class="product-info">
      <text class="product-name">{{item.name}}</text>
      <text class="product-desc">{{item.description}}</text>
      
      <view class="product-price">
        <text class="current-price">¥{{item.currentPrice}}</text>
        <text a:if="{{item.originalPrice > item.currentPrice}}" 
              class="original-price">¥{{item.originalPrice}}</text>
      </view>
      
      <view class="product-tags">
        <text a:for="{{item.tags}}" 
              a:key="*this" 
              class="tag">{{item}}</text>
      </view>
    </view>
    
    <view class="product-actions">
      <button class="add-cart-btn" 
              onTap="onAddToCart" 
              data-product="{{item}}">
        加入购物车
      </button>
    </view>
  </view>
</view>
```

### 条件渲染（a:if）

#### 1. 基础条件渲染
```xml
<!-- 简单条件 -->
<text a:if="{{isLoggedIn}}">欢迎回来!</text>
<text a:else>请先登录</text>

<!-- 多重条件 -->
<text a:if="{{userType === 'vip'}}">VIP用户</text>
<text a:elif="{{userType === 'premium'}}">高级用户</text>
<text a:else>普通用户</text>
```

#### 2. 复杂条件判断
```xml
<!-- 组合条件 -->
<view a:if="{{isLoggedIn && userInfo.verified}}">
  <text>已验证用户专区</text>
</view>

<!-- 状态控制 -->
<view a:if="{{loading}}">
  <text>加载中...</text>
</view>
<view a:elif="{{error}}">
  <text>加载失败: {{error.message}}</text>
</view>
<view a:else>
  <view a:for="{{dataList}}" a:key="id">
    <text>{{item.name}}</text>
  </view>
</view>
```

#### 3. hidden vs a:if
```xml
<!-- a:if: 条件为false时完全不渲染 -->
<view a:if="{{showContent}}">这个view会被销毁和重建</view>

<!-- hidden: 始终渲染，通过样式控制显示隐藏 -->
<view hidden="{{!showContent}}">这个view始终存在DOM中</view>
```

**使用场景选择：**
- `a:if`: 条件切换频率低，渲染成本高
- `hidden`: 条件切换频率高，渲染成本低

### 模板引用

#### 1. template定义和使用
```xml
<!-- 定义模板 -->
<template name="userItem">
  <view class="user-item">
    <image class="avatar" src="{{avatar}}" />
    <text class="username">{{name}}</text>
    <text class="user-email">{{email}}</text>
  </view>
</template>

<!-- 使用模板 -->
<template is="userItem" data="{{...userInfo}}" />

<!-- 在循环中使用模板 -->
<template a:for="{{userList}}" a:key="id" is="userItem" data="{{...item}}" />
```

#### 2. 动态模板选择
```xml
<!-- 根据条件选择不同模板 -->
<template name="textMessage">
  <text>{{content}}</text>
</template>

<template name="imageMessage">
  <image src="{{imageUrl}}" />
</template>

<template name="videoMessage">
  <video src="{{videoUrl}}" />
</template>

<!-- 动态选择模板 -->
<view a:for="{{messages}}" a:key="id">
  <template is="{{item.type + 'Message'}}" data="{{...item}}" />
</view>
```

#### 3. 模板文件引入
```xml
<!-- 引入外部模板文件 -->
<import src="./templates/user-item.axml" />
<include src="./templates/header.axml" />

<!-- 使用引入的模板 -->
<template is="userItem" data="{{...userData}}" />
```

### 数据更新机制

#### 1. setData方法详解
```javascript
Page({
  data: {
    message: 'Hello',
    userInfo: {
      name: 'John',
      age: 25
    },
    list: [1, 2, 3]
  },
  
  // 基础用法
  updateMessage() {
    this.setData({
      message: 'Hello World'
    });
  },
  
  // 更新对象属性
  updateUserName() {
    this.setData({
      'userInfo.name': 'Jane'
    });
  },
  
  // 更新数组元素
  updateListItem() {
    this.setData({
      'list[0]': 10
    });
  },
  
  // 批量更新
  batchUpdate() {
    this.setData({
      message: 'Updated',
      'userInfo.age': 26,
      'list[1]': 20
    });
  }
});
```

#### 2. 性能优化技巧
```javascript
Page({
  data: {
    largeList: []
  },
  
  // 避免频繁调用setData
  updateMultipleItems() {
    // ❌ 错误做法 - 多次调用
    // this.setData({ 'list[0]': 1 });
    // this.setData({ 'list[1]': 2 });
    // this.setData({ 'list[2]': 3 });
    
    // ✅ 正确做法 - 批量更新
    this.setData({
      'list[0]': 1,
      'list[1]': 2,
      'list[2]': 3
    });
  },
  
  // 只更新需要变化的数据
  updatePartialData() {
    // ❌ 更新整个大对象
    // this.setData({
    //   largeObject: { ...this.data.largeObject, name: 'new name' }
    // });
    
    // ✅ 只更新变化的字段
    this.setData({
      'largeObject.name': 'new name'
    });
  },
  
  // 异步更新处理
  async loadData() {
    this.setData({ loading: true });
    
    try {
      const result = await this.fetchData();
      this.setData({
        loading: false,
        dataList: result.list,
        total: result.total
      });
    } catch (error) {
      this.setData({
        loading: false,
        error: error.message
      });
    }
  }
});
```

#### 3. 数据观察和响应
```javascript
Page({
  data: {
    count: 0,
    computedValue: 0
  },
  
  onLoad() {
    // 数据变化监听（需要手动实现）
    this.watchData('count', (newVal, oldVal) => {
      console.log(`count changed from ${oldVal} to ${newVal}`);
      // 计算衍生数据
      this.setData({
        computedValue: newVal * 2
      });
    });
  },
  
  // 简单的数据监听实现
  watchData(key, callback) {
    const originalSetData = this.setData;
    this.setData = (data, cb) => {
      const oldValue = this.data[key];
      originalSetData.call(this, data, () => {
        const newValue = this.data[key];
        if (oldValue !== newValue) {
          callback(newValue, oldValue);
        }
        cb && cb();
      });
    };
  },
  
  increment() {
    this.setData({
      count: this.data.count + 1
    });
  }
});
```

---

## 3.2 页面数据管理

### Page数据管理

#### 1. 数据初始化
```javascript
Page({
  data: {
    // 基础数据类型
    title: '页面标题',
    isVisible: true,
    count: 0,
    
    // 对象数据
    userInfo: {
      name: '',
      avatar: '',
      level: 1
    },
    
    // 数组数据
    menuList: [],
    selectedItems: [],
    
    // 状态管理
    loading: false,
    error: null,
    
    // 页面配置
    pageConfig: {
      pageSize: 20,
      currentPage: 1,
      hasMore: true
    }
  },
  
  onLoad(query) {
    // 根据页面参数初始化数据
    if (query.id) {
      this.loadUserData(query.id);
    }
    
    // 初始化页面配置
    this.initPageConfig();
  },
  
  initPageConfig() {
    const systemInfo = my.getSystemInfoSync();
    this.setData({
      'pageConfig.screenWidth': systemInfo.screenWidth,
      'pageConfig.screenHeight': systemInfo.screenHeight
    });
  }
});
```

#### 2. 数据状态管理
```javascript
Page({
  data: {
    // 页面状态枚举
    pageStatus: 'loading', // loading | loaded | error | empty
    
    // 请求状态
    requestStates: {
      userInfo: 'idle',    // idle | loading | success | error
      orderList: 'idle',
      statistics: 'idle'
    }
  },
  
  // 统一的状态更新方法
  updateRequestState(key, state, data = null, error = null) {
    this.setData({
      [`requestStates.${key}`]: state,
      ...(data && { [key]: data }),
      ...(error && { [`${key}Error`]: error })
    });
  },
  
  // 加载用户信息
  async loadUserInfo(userId) {
    this.updateRequestState('userInfo', 'loading');
    
    try {
      const userInfo = await api.getUserInfo(userId);
      this.updateRequestState('userInfo', 'success', userInfo);
    } catch (error) {
      this.updateRequestState('userInfo', 'error', null, error.message);
    }
  },
  
  // 页面状态控制
  updatePageStatus() {
    const { userInfo, orderList } = this.data.requestStates;
    
    if (userInfo === 'loading' || orderList === 'loading') {
      this.setData({ pageStatus: 'loading' });
    } else if (userInfo === 'error' || orderList === 'error') {
      this.setData({ pageStatus: 'error' });
    } else if (this.data.orderList.length === 0) {
      this.setData({ pageStatus: 'empty' });
    } else {
      this.setData({ pageStatus: 'loaded' });
    }
  }
});
```

### setData方法深入使用

#### 1. 高级更新技巧
```javascript
Page({
  data: {
    user: {
      profile: {
        personal: {
          name: 'John',
          age: 25
        },
        contact: {
          email: 'john@example.com',
          phone: '123456789'
        }
      },
      preferences: {
        theme: 'light',
        language: 'zh-CN'
      }
    },
    orders: [
      { id: 1, status: 'pending', amount: 100 },
      { id: 2, status: 'completed', amount: 200 }
    ]
  },
  
  // 深层对象更新
  updateUserName(newName) {
    this.setData({
      'user.profile.personal.name': newName
    });
  },
  
  // 数组操作
  addOrder(order) {
    this.setData({
      orders: [...this.data.orders, order]
    });
  },
  
  updateOrderStatus(orderId, status) {
    const orders = this.data.orders.map(order => 
      order.id === orderId ? { ...order, status } : order
    );
    this.setData({ orders });
  },
  
  removeOrder(orderId) {
    const orders = this.data.orders.filter(order => order.id !== orderId);
    this.setData({ orders });
  },
  
  // 条件更新
  conditionalUpdate(shouldUpdate, newData) {
    if (shouldUpdate) {
      this.setData(newData);
    }
  },
  
  // 计算后更新
  updateWithCalculation() {
    const total = this.data.orders.reduce((sum, order) => sum + order.amount, 0);
    const averageAmount = total / this.data.orders.length;
    
    this.setData({
      orderTotal: total,
      averageAmount: averageAmount.toFixed(2)
    });
  }
});
```

#### 2. 性能优化实践
```javascript
Page({
  data: {
    bigList: new Array(1000).fill(0).map((_, i) => ({ id: i, value: i }))
  },
  
  // 分页更新大数据
  updateBigListItem(index, newValue) {
    // ❌ 更新整个数组会很慢
    // const newList = [...this.data.bigList];
    // newList[index] = newValue;
    // this.setData({ bigList: newList });
    
    // ✅ 只更新特定索引
    this.setData({
      [`bigList[${index}]`]: newValue
    });
  },
  
  // 批量更新优化
  batchUpdateItems(updates) {
    const setDataObj = {};
    updates.forEach(({ index, value }) => {
      setDataObj[`bigList[${index}].value`] = value;
    });
    this.setData(setDataObj);
  },
  
  // 防抖更新
  debouncedUpdate: null,
  
  onInput(e) {
    clearTimeout(this.debouncedUpdate);
    this.debouncedUpdate = setTimeout(() => {
      this.setData({
        searchKeyword: e.detail.value
      });
      this.performSearch();
    }, 300);
  },
  
  // 节流更新
  throttledUpdate: false,
  
  onScroll() {
    if (this.throttledUpdate) return;
    
    this.throttledUpdate = true;
    setTimeout(() => {
      this.updateScrollState();
      this.throttledUpdate = false;
    }, 100);
  }
});
```

### 数据流管理

#### 1. 单向数据流
```javascript
// 父组件向子组件传递数据
Page({
  data: {
    parentData: {
      title: '父组件数据',
      list: [1, 2, 3]
    }
  },
  
  // 处理子组件事件
  onChildEvent(e) {
    const { type, data } = e.detail;
    
    switch (type) {
      case 'update':
        this.setData({
          'parentData.title': data.title
        });
        break;
      case 'add':
        this.setData({
          'parentData.list': [...this.data.parentData.list, data.item]
        });
        break;
    }
  }
});
```

#### 2. 组件间通信
```javascript
// 页面数据管理中心
Page({
  data: {
    sharedState: {
      currentUser: null,
      cartItems: [],
      notifications: []
    }
  },
  
  // 全局状态更新方法
  updateSharedState(key, value) {
    this.setData({
      [`sharedState.${key}`]: value
    });
    
    // 通知所有子组件状态变化
    this.notifyComponents('stateChanged', { key, value });
  },
  
  // 通知所有子组件
  notifyComponents(eventName, data) {
    // 可以通过 selectComponent 获取子组件实例
    const components = this.selectAllComponents();
    components.forEach(comp => {
      if (comp.onStateChanged) {
        comp.onStateChanged(data);
      }
    });
  },
  
  // 处理全局事件
  onGlobalEvent(e) {
    const { action, payload } = e.detail;
    
    switch (action) {
      case 'ADD_TO_CART':
        this.addToCart(payload.product);
        break;
      case 'REMOVE_FROM_CART':
        this.removeFromCart(payload.productId);
        break;
      case 'UPDATE_USER':
        this.updateUser(payload.userInfo);
        break;
    }
  },
  
  addToCart(product) {
    const cartItems = [...this.data.sharedState.cartItems];
    const existingItem = cartItems.find(item => item.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += 1;
    } else {
      cartItems.push({ ...product, quantity: 1 });
    }
    
    this.updateSharedState('cartItems', cartItems);
  }
});
```

---

## 学习要点总结

### 核心概念
- 数据绑定的语法和使用场景
- 列表渲染和条件渲染的实现方式
- setData方法的工作原理和优化策略
- 页面数据状态管理的最佳实践

### 实践技能
- 熟练使用各种数据绑定语法
- 能够实现复杂的列表和条件渲染
- 掌握高效的数据更新方法
- 建立良好的数据管理架构

### 性能优化要点
1. **减少setData调用频率**: 批量更新，避免频繁调用
2. **精确更新**: 只更新变化的数据，避免大对象替换
3. **异步处理**: 合理使用防抖和节流
4. **数据结构优化**: 选择合适的数据结构提高更新效率

### 常见问题
1. **数据更新不及时**: 检查setData调用和数据路径
2. **性能问题**: 避免在循环中频繁调用setData
3. **数据同步**: 理解异步更新机制
4. **内存泄漏**: 及时清理定时器和监听器
